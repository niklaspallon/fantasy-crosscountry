import 'package:flutter/material.dart' show BuildContext;
import 'package:cloud_firestore/cloud_firestore.dart';
import 'week_handler.dart';
import '../providers/team_provider.dart';
import 'package:provider/provider.dart';
import 'leaderboard_handler.dart';

/// üîπ H√§mta veckopo√§ng (`weeklyPoints`) f√∂r ett lag en given vecka
Future<int> getWeeklyTeamPoints(String teamID, int weeknumber) async {
  try {
    print("getWeeklyTeamPoints, k√∂rs");
    FirebaseFirestore db = FirebaseFirestore.instance;
    DocumentSnapshot weeklyTeamDoc = await db
        .collection('teams')
        .doc(teamID)
        .collection('weeklyTeams')
        .doc("week$weeknumber")
        .get();

    if (!weeklyTeamDoc.exists) {
      print("weeklyteam doc finns inte f√∂r $teamID f√∂r vecka $weeknumber");
      return 0; // or any fallback value
    }
    Map<String, dynamic> data = weeklyTeamDoc.data() as Map<String, dynamic>;
    int weeklyPoints = data['weeklyPoints'] ?? 0;
    return weeklyPoints;
  } catch (e) {
    print(e);
    return 0;
  }
}

/// üîπ H√§mta alla lagens `weeklyPoints` direkt fr√•n weeklyTeams
Future<Map<String, int>> getAllTeamsWeeklyPoints(
    List<String> teamIds, int weekNumber) async {
  print("getAllTeamsWeeklyPoints, k√∂rs");
  Map<String, int> teamPointsMap = {};
  FirebaseFirestore db = FirebaseFirestore.instance;

  try {
    // üîπ H√§mta alla weeklyTeams-dokument i en batch
    List<Future<DocumentSnapshot>> futures = teamIds.map((teamId) {
      return db
          .collection('teams')
          .doc(teamId)
          .collection('weeklyTeams')
          .doc("week$weekNumber")
          .get();
    }).toList();

    List<DocumentSnapshot> teamDocs = await Future.wait(futures);

    for (int i = 0; i < teamIds.length; i++) {
      String teamId = teamIds[i];
      DocumentSnapshot teamDoc = teamDocs[i];

      if (!teamDoc.exists) {
        print("‚ö†Ô∏è Lag $teamId saknar dokument f√∂r vecka $weekNumber.");
        teamPointsMap[teamId] = 0;
        continue;
      }

      final data = teamDoc.data() as Map<String, dynamic>?;

      if (data != null && data.containsKey('weeklyPoints')) {
        int points = data['weeklyPoints'] ?? 0;
        teamPointsMap[teamId] = points;
        print("‚úÖ Lag $teamId har $points po√§ng f√∂r vecka $weekNumber.");
      } else {
        print("‚ö†Ô∏è Lag $teamId saknar `weeklyPoints`-f√§lt.");
        teamPointsMap[teamId] = 0;
      }
    }
  } catch (e) {
    print("‚ùå Fel vid h√§mtning av weeklyPoints: $e");
  }

  return teamPointsMap;
}

/// üîπ H√§mta skid√•kare och deras po√§ng direkt fr√•n weeklyTeams (ingen extra l√§sning fr√•n SkiersDb)
/// üîπ Lokal cache
final Map<String, List<Map<String, dynamic>>> _teamCache = {};

/// üîπ H√§mtar skid√•kare + po√§ng fr√•n cache eller Firestore
Future<List<Map<String, dynamic>>> getTeamSkiersWithPoints(
    String teamId, int weekNumber, BuildContext context) async {
  print("getTeamSkiersWithPoints, k√∂rs");
  final String cacheKey = "$teamId-$weekNumber";
  FirebaseFirestore db = FirebaseFirestore.instance;
  final deadline = context.read<TeamProvider>().weekDeadline;

  if (deadline == null) {
    print("‚ö†Ô∏è Ingen deadline hittad i TeamProvider");
    return [];
  }

  // üîπ Om det redan finns i cachen ‚Äì anv√§nd det direkt
  if (_teamCache.containsKey(cacheKey)) {
    print("‚ôªÔ∏è H√§mtar lag fr√•n cache: $cacheKey");
    return _teamCache[cacheKey]!;
  }

  try {
    print("üì° H√§mtar lag fr√•n Firestore: $cacheKey");

    bool isDeadlinePassed = DateTime.now().isAfter(deadline);

    // Om deadline inte har passerat, f√∂rs√∂k h√§mta f√∂rra veckans lag
    if (!isDeadlinePassed) {
      print("‚è∞ Deadline har inte passerat f√∂r vecka $weekNumber");
      if (weekNumber > 1) {
        print("üìÖ H√§mtar lag fr√•n vecka ${weekNumber - 1} ist√§llet");
        return getTeamSkiersWithPoints(teamId, weekNumber - 1, context);
      } else {
        print("‚ö†Ô∏è F√∂rsta veckan och deadline har inte passerat");
        return [];
      }
    }

    // H√§mta laget f√∂r den aktuella veckan
    DocumentSnapshot weeklyTeamDoc = await db
        .collection('teams')
        .doc(teamId)
        .collection('weeklyTeams')
        .doc("week$weekNumber")
        .get();

    if (!weeklyTeamDoc.exists) {
      print("‚ö†Ô∏è Inget lag hittades f√∂r vecka $weekNumber");
      return [];
    }

    Map<String, dynamic> data = weeklyTeamDoc.data() as Map<String, dynamic>;
    List<dynamic> skiersRaw = data['skiers'] ?? [];

    List<Map<String, dynamic>> skiers = skiersRaw.map((skierData) {
      return {
        'skierId': skierData['skierId'],
        'name': skierData['name'],
        'country': skierData['country'],
        'points': skierData['totalWeeklyPoints'],
        'isCaptain': skierData['isCaptain'] ?? false,
        'gender': skierData['gender'] ?? 'Male',
      };
    }).toList();

    // Sortera s√• att tjejer kommer f√∂rst (index 0-2) och killar sist (index 3-5)
    skiers.sort((a, b) {
      // F√∂rst sortera p√• k√∂n (tjejer f√∂rst)
      if (a['gender'] != b['gender']) {
        return a['gender'] == 'Female' ? -1 : 1;
      }
      // Om samma k√∂n, beh√•ll originalordningen
      return 0;
    });

    // üîπ Spara i cache
    _teamCache[cacheKey] = skiers;

    return skiers;
  } catch (e) {
    print("‚ùå Fel vid h√§mtning av lagets skid√•kare med po√§ng: $e");
    return [];
  }
}

// /// üî¢ R√§kna ut aktuell leaderboard (live) f√∂r given vecka ALLT DESSSA FUNKTIONER UNDER LIGGER I HANDLER
// Future<List<Map<String, dynamic>>> calculateLiveLeaderboard(int week) async {
//   print("calculateLiveLeaderboard, k√∂rs");
//   try {
//     final db = FirebaseFirestore.instance;

//     // üîπ H√§mta alla lag
//     QuerySnapshot teamsSnapshot = await db.collection('teams').get();

//     List<Map<String, dynamic>> teams = teamsSnapshot.docs.map((doc) {
//       final data = doc.data() as Map<String, dynamic>;
//       data['teamId'] = doc.id;
//       return data;
//     }).toList();

//     // üîπ H√§mta veckopo√§ng f√∂r lagen
//     List<String> teamIds =
//         teams.map((team) => team['teamId'] as String).toList();
//     Map<String, int> weeklyPointsMap =
//         await getAllTeamsWeeklyPoints(teamIds, week);

//     // üîπ L√§gg till po√§ng & sortera
//     for (var team in teams) {
//       team['weeklyPoints'] = weeklyPointsMap[team['teamId']] ?? 0;
//     }

//     teams.sort(
//         (a, b) => (b['totalPoints'] ?? 0).compareTo(a['totalPoints'] ?? 0));

//     return teams;
//   } catch (e) {
//     print("‚ùå Fel vid live-ber√§kning av leaderboard: $e");
//     return [];
//   }
// }

// /// üü° Tillf√§llig leaderboard-cache (f√∂r uppdateringar mellan t√§vlingar)
// Future<void> cacheTemporaryLeaderboard() async {
//   print("cacheTemporaryLeaderboard, k√∂rs");
//   try {
//     int currentWeek = await getCurrentWeek();
//     final db = FirebaseFirestore.instance;

//     final leaderboard = await calculateLiveLeaderboard(currentWeek);
//     print("üîç Sparar f√∂ljande leaderboard: ${leaderboard.length} lag");

//     await db
//         .collection('cachedData')
//         .doc("leaderboard_week${currentWeek}_temp")
//         .set({
//       'teams': leaderboard,
//       'timestamp': FieldValue.serverTimestamp(),
//     });

//     print("üü° Tillf√§llig leaderboard-cache uppdaterad f√∂r vecka $currentWeek!");
//   } catch (e) {
//     print("‚ùå Fel vid tempor√§r leaderboard-cache: $e");
//   }
// }

// /// ‚úÖ Slutgiltig leaderboard-cache (efter sista t√§vlingen)
// Future<void> finalizeLeaderboardCache() async {
//   print("finalizeLeaderboardCache, k√∂rs");
//   try {
//     int currentWeek = await getCurrentWeek();
//     final db = FirebaseFirestore.instance;

//     final leaderboard = await calculateLiveLeaderboard(currentWeek);

//     await db.collection('cachedData').doc("leaderboard_week$currentWeek").set({
//       'teams': leaderboard,
//       'timestamp': FieldValue.serverTimestamp(),
//     });

//     print("‚úÖ Permanent leaderboard-cache sparad f√∂r vecka $currentWeek!");
//   } catch (e) {
//     print("‚ùå Fel vid sparande av permanent leaderboard-cache: $e");
//   }
// }

// /// üì≤ H√§mta senaste tillg√§ngliga leaderboard (f√∂r att visa i UI)
// Future<List<Map<String, dynamic>>> fetchLatestAvailableLeaderboard() async {
//   print("fetchLatestAvailableLeaderboard, k√∂rs");
//   try {
//     final db = FirebaseFirestore.instance;
//     QuerySnapshot snapshot = await db.collection('cachedData').get();

//     List<QueryDocumentSnapshot> leaderboardDocs = snapshot.docs.where((doc) {
//       return doc.id.startsWith('leaderboard_week') && !doc.id.endsWith('_temp');
//     }).toList();

//     if (leaderboardDocs.isEmpty) {
//       print("‚ö†Ô∏è Ingen leaderboard-cache hittades.");
//       return [];
//     }

//     leaderboardDocs.sort((a, b) {
//       int aWeek = int.tryParse(a.id.replaceAll('leaderboard_week', '')) ?? 0;
//       int bWeek = int.tryParse(b.id.replaceAll('leaderboard_week', '')) ?? 0;
//       return bWeek.compareTo(aWeek);
//     });

//     DocumentSnapshot latestDoc = leaderboardDocs.first;
//     List<dynamic> teamsRaw = latestDoc.get('teams');

//     return List<Map<String, dynamic>>.from(teamsRaw);
//   } catch (e) {
//     print("‚ùå Fel vid h√§mtning av senaste leaderboard-cache: $e");
//     return [];
//   }
// }

// Future<List<Map<String, dynamic>>> fetchBestAvailableLeaderboard() async {
//   print("fetchBestAvailableLeaderboard, k√∂rs");
//   try {
//     final db = FirebaseFirestore.instance;
//     int currentWeek = await getCurrentWeek();

//     // üîπ F√∂rs√∂k h√§mta PERMANENT leaderboard f√∂rst
//     DocumentSnapshot finalDoc = await db
//         .collection('cachedData')
//         .doc("leaderboard_week$currentWeek")
//         .get();

//     if (finalDoc.exists && finalDoc.data() != null) {
//       print("‚úÖ Visar permanent leaderboard f√∂r vecka $currentWeek");
//       List<dynamic> teamsRaw = finalDoc.get('teams');
//       return List<Map<String, dynamic>>.from(teamsRaw);
//     }

//     // üîπ Om ingen permanent finns, visa TEMP
//     DocumentSnapshot tempDoc = await db
//         .collection('cachedData')
//         .doc("leaderboard_week${currentWeek}_temp")
//         .get();

//     if (tempDoc.exists && tempDoc.data() != null) {
//       print("üü° Visar tillf√§llig leaderboard f√∂r vecka $currentWeek");
//       List<dynamic> teamsRaw = tempDoc.get('teams');
//       return List<Map<String, dynamic>>.from(teamsRaw);
//     }

//     // üîπ Om inget av ovan finns: visa senaste permanenta
//     print(
//         "‚è≠ Ingen leaderboard f√∂r vecka $currentWeek ‚Äì visar senaste tillg√§ngliga.");
//     return await fetchLatestAvailableLeaderboard();
//   } catch (e) {
//     print("‚ùå Fel vid h√§mtning av b√§sta tillg√§ngliga leaderboard: $e");
//     return [];
//   }
// }
